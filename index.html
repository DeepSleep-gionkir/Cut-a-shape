<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Ultimate Slice - Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0f172a; 
            font-family: 'Helvetica Neue', 'Noto Sans KR', sans-serif; 
            overscroll-behavior: none;
            user-select: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            touch-action: none; 
            outline: none;
        }

        /* UI Styles */
        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .glass-btn:active { transform: scale(0.92); background: rgba(255, 255, 255, 0.2); }
        
        .active-mode {
            background: rgba(34, 211, 238, 0.2);
            border-color: #22d3ee;
            color: #22d3ee;
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.2);
        }

        .btn-cut {
            background: linear-gradient(135deg, #f43f5e, #e11d48);
            color: white;
            box-shadow: 0 8px 20px rgba(244, 63, 94, 0.4);
        }
        .btn-cut:active { transform: scale(0.95); }

        .btn-reset {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        .btn-reset:active { transform: scale(0.95); }

        .menu-dropdown {
            transform-origin: top left;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
        }
        .scale-0-opacity-0 { transform: scale(0.8); opacity: 0; pointer-events: none; }
        .scale-100-opacity-100 { transform: scale(1); opacity: 1; pointer-events: auto; }

        .color-swatch {
            width: 24px; height: 24px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer; transition: transform 0.2s;
        }
        .shape-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(255,255,255,0.05); border-radius: 12px;
            transition: background 0.2s;
        }
        .shape-btn:hover { background: rgba(255,255,255,0.15); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="fixed top-0 left-0 p-5 flex gap-3 pointer-events-none z-50 items-start">
        <div class="relative pointer-events-auto">
            <button id="btn-shape-toggle" class="glass-btn w-12 h-12 rounded-2xl flex items-center justify-center"><i id="current-shape-icon" class="fas fa-shapes"></i></button>
            <div id="shape-menu" class="menu-dropdown absolute top-14 left-0 bg-slate-800/95 backdrop-blur-xl border border-slate-600 rounded-2xl p-3 w-56 shadow-2xl scale-0-opacity-0 grid grid-cols-3 gap-2">
                <button onclick="changeShape('cone')" class="shape-btn p-3 text-yellow-400"><i class="fas fa-filter transform rotate-180"></i><span class="text-[9px] text-gray-300">Cone</span></button>
                <button onclick="changeShape('cube')" class="shape-btn p-3 text-blue-400"><i class="fas fa-cube"></i><span class="text-[9px] text-gray-300">Cube</span></button>
                <button onclick="changeShape('sphere')" class="shape-btn p-3 text-red-400"><i class="fas fa-circle"></i><span class="text-[9px] text-gray-300">Sphere</span></button>
                <button onclick="changeShape('cylinder')" class="shape-btn p-3 text-green-400"><i class="fas fa-database"></i><span class="text-[9px] text-gray-300">Cylinder</span></button>
                <button onclick="changeShape('torus')" class="shape-btn p-3 text-purple-400"><i class="fas fa-ring"></i><span class="text-[9px] text-gray-300">Torus</span></button>
                <button onclick="changeShape('icosahedron')" class="shape-btn p-3 text-orange-400"><i class="fas fa-dice-d20"></i><span class="text-[9px] text-gray-300">Icosa</span></button>
            </div>
        </div>
        <div class="relative pointer-events-auto">
            <button id="btn-color-toggle" class="glass-btn w-12 h-12 rounded-2xl flex items-center justify-center"><i class="fas fa-palette"></i></button>
            <div id="color-menu" class="menu-dropdown absolute top-14 left-0 bg-slate-800/95 backdrop-blur-xl border border-slate-600 rounded-2xl p-4 w-48 shadow-2xl scale-0-opacity-0">
                <p class="text-[10px] text-gray-400 uppercase tracking-wider mb-2 font-bold">Shape Color</p>
                <div class="flex flex-wrap gap-2 mb-4">
                    <div onclick="changeColor(0x06b6d4, 0xf43f5e)" class="color-swatch bg-cyan-500 shadow-[0_0_10px_#06b6d4]"></div>
                    <div onclick="changeColor(0xf59e0b, 0x3b82f6)" class="color-swatch bg-amber-500 shadow-[0_0_10px_#f59e0b]"></div>
                    <div onclick="changeColor(0x10b981, 0x8b5cf6)" class="color-swatch bg-emerald-500 shadow-[0_0_10px_#10b981]"></div>
                    <div onclick="changeColor(0xec4899, 0xfacc15)" class="color-swatch bg-pink-500 shadow-[0_0_10px_#ec4899]"></div>
                    <div onclick="changeColor(0x6366f1, 0x14b8a6)" class="color-swatch bg-indigo-500 shadow-[0_0_10px_#6366f1]"></div>
                </div>
            </div>
        </div>
        <button id="btn-ai" class="pointer-events-auto glass-btn w-12 h-12 rounded-2xl flex items-center justify-center hover:text-purple-400"><i class="fas fa-brain"></i></button>
    </div>

    <div class="fixed top-0 right-0 p-5 z-50">
        <button id="btn-reset" class="pointer-events-auto btn-reset w-14 h-14 rounded-2xl flex flex-col items-center justify-center font-bold text-[10px] shadow-xl border border-white/20 active:scale-95 transition-transform">
            <i class="fas fa-redo text-lg mb-0.5"></i>
            RESET
        </button>
    </div>

    <div class="fixed bottom-10 left-0 right-0 z-50 flex justify-center items-center gap-6 pointer-events-none pb-4">
        <div class="pointer-events-auto bg-black/40 backdrop-blur-md rounded-full p-1.5 flex border border-white/10 shadow-xl">
            <button id="btn-mode-translate" class="active-mode w-12 h-12 rounded-full flex items-center justify-center transition-all"><i class="fas fa-arrows-alt"></i></button>
            <button id="btn-mode-rotate" class="w-12 h-12 rounded-full text-slate-400 flex items-center justify-center transition-all hover:text-white hover:bg-white/10"><i class="fas fa-sync-alt"></i></button>
        </div>
        <button id="btn-cut" class="pointer-events-auto btn-cut w-24 h-24 rounded-3xl rotate-3 flex flex-col items-center justify-center font-black text-sm shadow-2xl border border-white/20 active:scale-95 transition-transform hover:rotate-0 group">
            <i class="fas fa-cut text-3xl mb-1 group-hover:scale-110 transition-transform"></i>
            CUT
        </button>
    </div>

    <div id="ai-modal" class="hidden fixed inset-0 z-[70] flex items-end sm:items-center justify-center pointer-events-none bg-black/60 backdrop-blur-sm">
        <div class="bg-slate-900 text-white w-full sm:w-96 max-h-[80vh] sm:rounded-2xl rounded-t-2xl shadow-2xl border border-slate-700 flex flex-col pointer-events-auto transform transition-transform duration-300 translate-y-full">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50 rounded-t-2xl">
                <h3 class="font-bold text-cyan-400"><i class="fas fa-robot mr-2"></i>Gemini Analysis</h3>
                <button id="close-ai" class="text-gray-400 hover:text-white p-2"><i class="fas fa-times"></i></button>
            </div>
            <div id="ai-content" class="p-6 overflow-y-auto custom-scroll text-sm leading-relaxed text-slate-300"></div>
        </div>
    </div>
    <div id="loading-overlay" class="hidden fixed inset-0 bg-black/80 z-[80] flex flex-col items-center justify-center text-white backdrop-blur-sm">
        <div class="animate-spin rounded-full h-12 w-12 border-4 border-t-cyan-500 border-slate-700 mb-4"></div>
        <p class="text-sm font-bold animate-pulse text-cyan-400 tracking-widest">GEMINI IS THINKING...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        const apiKey = ""; 
        
        let scene, camera, renderer, orbitControls, transformControl;
        let objectGroup, capGroup, bladeGroup; // CapGroup을 분리
        
        let isAnimating = false;
        let currentShapeType = 'cone';
        let currentShapeColor = 0x06b6d4;
        let currentCapColor = 0xf43f5e;
        
        // [Core Logic]
        let committedPlanes = [];
        let activePlane = null;
        let activeCapMesh = null; 

        const INITIAL_CAMERA_POS = new THREE.Vector3(0, 12, 20);
        const INITIAL_BLADE_POS = new THREE.Vector3(0, 9, 0);
        let INITIAL_BLADE_QUAT = new THREE.Quaternion(); // To store initial rotation
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); 
            scene.fog = new THREE.FogExp2(0x0f172a, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(INITIAL_CAMERA_POS);
            camera.lookAt(0, 0, 0);

            // Stencil 사용을 위해 logarithmicDepthBuffer를 끄고 stencil: true 확인
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, stencil: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.localClippingEnabled = true; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048; 
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            const rimLight = new THREE.SpotLight(0x22d3ee, 2.0); 
            rimLight.position.set(-10, 10, -10);
            scene.add(rimLight);

            // [FIX 1] 그룹 구조 변경
            // objectGroup: 실제 3D 모델 (Stencil Write)
            objectGroup = new THREE.Group();
            objectGroup.position.y = 3.5; 
            scene.add(objectGroup);

            // capGroup: 단면 (Stencil Read) - Scene에 직접 추가하여 월드 좌표계 사용
            capGroup = new THREE.Group();
            scene.add(capGroup);

            // 초기화
            activePlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 1000); // 1000 = 안보이게 초기화
            updateSolidShape('cone');

            createBlade();
            INITIAL_BLADE_QUAT.copy(bladeGroup.quaternion); // 저장
            
            createFloor();

            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;

            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('change', () => renderer.render(scene, camera));
            transformControl.addEventListener('dragging-changed', (event) => {
                orbitControls.enabled = !event.value;
                if(event.value && !isAnimating) syncActivePlane();
            });
            transformControl.setSpace('local');
            transformControl.attach(bladeGroup);
            scene.add(transformControl);
            
            // 실시간 미리보기
            transformControl.addEventListener('change', () => {
                if(!isAnimating) syncActivePlane();
            });

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // 초기 싱크
            syncActivePlane();
        }

        // --- Stencil Cap Logic Fixed ---

        function getGeometry(type) {
            switch(type) {
                case 'cone': return new THREE.CylinderGeometry(0, 4.5, 7, 64);
                case 'cube': return new THREE.BoxGeometry(6, 6, 6);
                case 'sphere': return new THREE.SphereGeometry(3.5, 64, 64);
                case 'cylinder': return new THREE.CylinderGeometry(3.5, 3.5, 7, 64);
                case 'torus': return new THREE.TorusGeometry(3.5, 1.2, 48, 100);
                case 'icosahedron': return new THREE.IcosahedronGeometry(4, 0);
                default: return new THREE.BoxGeometry(5,5,5);
            }
        }

        function updateSolidShape(type) {
            // 1. Clean up Old Meshes
            while(objectGroup.children.length > 0){ 
                const child = objectGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                objectGroup.remove(child);
            }
            while(capGroup.children.length > 0){
                const child = capGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                capGroup.remove(child);
            }

            const geometry = getGeometry(type);
            const allPlanes = [activePlane, ...committedPlanes];

            // [FIX 2] 렌더링 순서와 Stencil Logic 명확화
            // Render Order 1: Back Faces (Increment Stencil)
            // Render Order 2: Front Faces (Decrement Stencil)
            // Render Order 3: Caps (Draw only where Stencil != 0)
            // Render Order 4: Main Mesh (Visual Surface)

            const stencilBaseMat = new THREE.MeshBasicMaterial({
                depthWrite: false, depthTest: false, colorWrite: false,
                stencilWrite: true, stencilFunc: THREE.AlwaysStencilFunc,
                clippingPlanes: allPlanes
            });

            // 1. Back Faces (Increment)
            const matBack = stencilBaseMat.clone();
            matBack.side = THREE.BackSide;
            matBack.stencilFail = THREE.IncrementWrapStencilOp;
            matBack.stencilZFail = THREE.IncrementWrapStencilOp;
            matBack.stencilZPass = THREE.IncrementWrapStencilOp;
            const meshBack = new THREE.Mesh(geometry, matBack);
            meshBack.renderOrder = 1;
            objectGroup.add(meshBack);

            // 2. Front Faces (Decrement)
            const matFront = stencilBaseMat.clone();
            matFront.side = THREE.FrontSide;
            matFront.stencilFail = THREE.DecrementWrapStencilOp;
            matFront.stencilZFail = THREE.DecrementWrapStencilOp;
            matFront.stencilZPass = THREE.DecrementWrapStencilOp;
            const meshFront = new THREE.Mesh(geometry, matFront);
            meshFront.renderOrder = 2;
            objectGroup.add(meshFront);

            // 3. The Caps (단면) - 월드 좌표계인 capGroup에 추가됨
            const capMat = new THREE.MeshStandardMaterial({
                color: currentCapColor,
                emissive: new THREE.Color(currentCapColor).multiplyScalar(0.4),
                metalness: 0.1, roughness: 0.1,
                stencilWrite: true,
                stencilRef: 0,
                stencilFunc: THREE.NotEqualStencilFunc, // 0이 아닌 곳(잘린 내부)에만 그리기
                stencilFail: THREE.ReplaceStencilOp,
                stencilZFail: THREE.ReplaceStencilOp,
                stencilZPass: THREE.ReplaceStencilOp,
                side: THREE.DoubleSide
            });

            const planeGeom = new THREE.PlaneGeometry(100, 100);

            // Active Cap (움직이는 칼날용)
            activeCapMesh = new THREE.Mesh(planeGeom, capMat);
            activeCapMesh.renderOrder = 3;
            // 렌더링 직전에 위치 동기화
            activeCapMesh.onBeforeRender = function() {
                activeCapMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), activePlane.normal);
                activeCapMesh.position.copy(activePlane.normal).multiplyScalar(-activePlane.constant);
            };
            capGroup.add(activeCapMesh);

            // Committed Caps (이미 잘린 단면들)
            committedPlanes.forEach(p => {
                const pMesh = new THREE.Mesh(planeGeom, capMat);
                pMesh.renderOrder = 3;
                pMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), p.normal);
                pMesh.position.copy(p.normal).multiplyScalar(-p.constant);
                capGroup.add(pMesh);
            });

            // 4. Main Visual Mesh (겉면)
            const material = new THREE.MeshStandardMaterial({
                color: currentShapeColor, 
                emissive: new THREE.Color(currentShapeColor).multiplyScalar(0.1), 
                roughness: 0.2, metalness: 0.6,
                clippingPlanes: allPlanes,
                clipShadows: true, 
                side: THREE.FrontSide, // FrontSide만 렌더링하여 아티팩트 방지
            });
            const mainMesh = new THREE.Mesh(geometry, material);
            mainMesh.castShadow = true; mainMesh.receiveShadow = true;
            mainMesh.renderOrder = 4; 
            objectGroup.add(mainMesh);
        }

        function createBlade() {
            bladeGroup = new THREE.Group();
            bladeGroup.position.copy(INITIAL_BLADE_POS);

            // 투명 플라스틱 칼날 느낌
            const bladeGeo = new THREE.BoxGeometry(14, 0.05, 14);
            const bladeMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.1, roughness: 0.1, transmission: 0.9, thickness: 0.5,
                transparent: true, opacity: 0.5, side: THREE.DoubleSide
            });
            const bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
            bladeMesh.renderOrder = 10; 
            
            // 네온 테두리
            const edges = new THREE.EdgesGeometry(bladeGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x22d3ee }));
            line.renderOrder = 11;

            bladeMesh.add(line);
            bladeGroup.add(bladeMesh);
            scene.add(bladeGroup);
        }

        function createFloor() {
            const grid = new THREE.GridHelper(50, 50, 0x334155, 0x1e293b);
            scene.add(grid);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.5 }));
            floor.rotation.x = -Math.PI / 2; floor.position.y = -0.01; floor.receiveShadow = true;
            scene.add(floor);
        }

        function syncActivePlane() {
            if (!bladeGroup || !activePlane) return;
            
            // 월드 매트릭스 강제 업데이트 (정확한 위치 계산 위함)
            bladeGroup.updateMatrixWorld(true);
            
            const normal = new THREE.Vector3(0, -1, 0).applyQuaternion(bladeGroup.quaternion).normalize();
            
            // 칼날의 실제 위치 (중심점)
            const point = bladeGroup.position.clone();
            
            // 평면 방정식: normal dot point + constant = 0
            // constant = - (normal dot point)
            activePlane.normal.copy(normal);
            activePlane.constant = -point.dot(normal);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        // UI & Controls
        const btnShapeToggle = document.getElementById('btn-shape-toggle');
        const shapeMenu = document.getElementById('shape-menu');
        const btnColorToggle = document.getElementById('btn-color-toggle');
        const colorMenu = document.getElementById('color-menu');
        const btnCut = document.getElementById('btn-cut');
        const btnReset = document.getElementById('btn-reset');
        const btnTranslate = document.getElementById('btn-mode-translate');
        const btnRotate = document.getElementById('btn-mode-rotate');

        function toggleMenu(menu) {
            const isOpen = menu.classList.contains('scale-100-opacity-100');
            closeAllMenus(); 
            if (!isOpen) { menu.classList.remove('scale-0-opacity-0'); menu.classList.add('scale-100-opacity-100'); }
        }
        function closeAllMenus() {
            [shapeMenu, colorMenu].forEach(m => { m.classList.remove('scale-100-opacity-100'); m.classList.add('scale-0-opacity-0'); });
        }
        function toggleActiveMode(active, inactive) {
            active.classList.add('active-mode'); active.style.color = '#22d3ee';
            inactive.classList.remove('active-mode'); inactive.style.color = '#94a3b8';
        }

        btnShapeToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(shapeMenu); });
        btnColorToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(colorMenu); });
        document.addEventListener('click', closeAllMenus);

        window.changeShape = function(type) {
            if(isAnimating) return;
            committedPlanes = [];
            if(activePlane) activePlane.constant = 1000;
            bladeGroup.position.copy(INITIAL_BLADE_POS);
            bladeGroup.quaternion.copy(INITIAL_BLADE_QUAT);
            currentShapeType = type;
            updateSolidShape(type);
            syncActivePlane();
            closeAllMenus();
        };

        window.changeColor = function(colorHex, capHex) {
            currentShapeColor = colorHex;
            currentCapColor = capHex;
            updateSolidShape(currentShapeType);
            closeAllMenus();
        };

        btnTranslate.addEventListener('click', (e) => { 
            e.stopPropagation(); transformControl.setMode('translate'); transformControl.setSpace('local'); toggleActiveMode(btnTranslate, btnRotate); 
        });
        btnRotate.addEventListener('click', (e) => { 
            e.stopPropagation(); transformControl.setMode('rotate'); transformControl.setSpace('local'); toggleActiveMode(btnRotate, btnTranslate); 
        });

        function onKeyDown(event) {
            if(!document.getElementById('ai-modal').classList.contains('hidden')) {
                if(event.key === 'Escape') document.getElementById('close-ai').click();
                return;
            }
            switch(event.key.toLowerCase()) {
                case 't': if(!isAnimating) document.getElementById('btn-mode-translate').click(); break;
                case 'r': if(!isAnimating) document.getElementById('btn-mode-rotate').click(); break;
                case ' ': case 'enter': btnCut.click(); break;
                case 'escape': btnReset.click(); closeAllMenus(); break;
            }
        }

        // --- CUT LOGIC (Improved) ---
        btnCut.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isAnimating) return; 
            isAnimating = true;
            transformControl.detach();

            // [FIX 3] 힐링(초기화) 제거 - 현재 칼 위치에서 바로 자르기 시작
            syncActivePlane(); 

            // 칼날의 방향 벡터 계산
            const bladeNormal = new THREE.Vector3(0, -1, 0).applyQuaternion(bladeGroup.quaternion).normalize();
            const worldDown = new THREE.Vector3(0, -1, 0);
            
            // 칼이 어느 방향으로 진행해야 자연스러운지 계산
            // 기본적으로는 아래로 내려가지만, 칼이 기울어져 있다면 그 법선 방향 고려
            let cutDirection = worldDown.clone();
            
            // 진행 거리
            const windUpDist = 3;  
            const cutDist = 20;    
            const originPos = bladeGroup.position.clone();
            
            // 애니메이션 키포인트
            const windUpPos = originPos.clone().add(bladeNormal.clone().multiplyScalar(windUpDist)); // 살짝 들어올림
            const chopPos = originPos.clone().add(bladeNormal.clone().multiplyScalar(-cutDist)); // 푹 찍음

            const tl = gsap.timeline({
                onComplete: () => {
                    isAnimating = false;
                    transformControl.attach(bladeGroup);
                    
                    // Commit: 현재의 ActivePlane을 영구 저장소로 이동
                    const committedPlane = activePlane.clone();
                    committedPlanes.push(committedPlane);
                    
                    // ActivePlane 리셋 (화면 밖으로)
                    activePlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 1000);
                    
                    // 렌더링 업데이트
                    updateSolidShape(currentShapeType);
                }
            });

            // 1. Wind Up (들어올리기)
            tl.to(bladeGroup.position, { 
                x: windUpPos.x, y: windUpPos.y, z: windUpPos.z, 
                duration: 0.3, 
                ease: "back.out(1.7)",
                onUpdate: () => syncActivePlane() 
            });

            // 2. Chop (내려치기)
            tl.to(bladeGroup.position, { 
                x: chopPos.x, y: chopPos.y, z: chopPos.z, 
                duration: 0.4, 
                ease: "power4.inOut", 
                onUpdate: () => syncActivePlane() 
            });

            // 3. Return (원위치 복귀)
            tl.to(bladeGroup.position, { 
                x: originPos.x, y: originPos.y, z: originPos.z, 
                duration: 0.5, 
                ease: "power2.out" 
            });
            
            // 마지막에 한번 더 싱크 (activePlane을 리셋하기 전 상태 보장)
            tl.call(() => syncActivePlane());
        });

        btnReset.addEventListener('click', (e) => {
            e.stopPropagation();
            gsap.killTweensOf(bladeGroup.position);
            isAnimating = false;
            committedPlanes = [];
            
            activePlane.constant = 1000;
            bladeGroup.position.copy(INITIAL_BLADE_POS);
            bladeGroup.quaternion.copy(INITIAL_BLADE_QUAT);
            
            currentShapeType = 'cone';
            updateSolidShape('cone');
            
            gsap.to(camera.position, { x: INITIAL_CAMERA_POS.x, y: INITIAL_CAMERA_POS.y, z: INITIAL_CAMERA_POS.z, duration: 1.0 });
            transformControl.attach(bladeGroup);
            syncActivePlane();
        });

        // AI Logic
        const btnAi = document.getElementById('btn-ai');
        const aiModal = document.getElementById('ai-modal');
        const closeAi = document.getElementById('close-ai');
        
        async function callGemini(prompt) {
            if (!apiKey) return "API Key Missing";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
            } catch (e) { return "Error"; }
        }

        btnAi.addEventListener('click', async (e) => {
            e.stopPropagation();
            aiModal.querySelector('div').classList.remove('translate-y-full');
            document.getElementById('loading-overlay').classList.remove('hidden');
            const prompt = `Math Teacher Persona. Korean Language. Context: 3D Slicing App. Shape: ${currentShapeType}. Explain the cross-section created by a plane cut.`;
            const result = await callGemini(prompt);
            document.getElementById('ai-content').innerHTML = result.replace(/\*\*(.*?)\*\*/g, '<span class="text-cyan-400 font-bold">$1</span>').replace(/\n/g, '<br>');
            document.getElementById('loading-overlay').classList.add('hidden');
        });

        closeAi.addEventListener('click', () => {
            aiModal.querySelector('div').classList.add('translate-y-full');
        });

        // Start
        init();
        animate();
    </script>
</body>
</html>
