<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Realistic Slice with Physics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0f172a; 
            font-family: 'Helvetica Neue', 'Noto Sans KR', sans-serif; 
            overscroll-behavior: none;
            user-select: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            touch-action: none; 
            outline: none;
        }

        /* Glass Button Style */
        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .glass-btn:active {
            transform: scale(0.92);
            background: rgba(255, 255, 255, 0.2);
        }
        
        .active-mode {
            background: rgba(34, 211, 238, 0.2);
            border-color: #22d3ee;
            color: #22d3ee;
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.2);
        }

        /* CUT Button Animation */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0.6); }
            70% { box-shadow: 0 0 0 15px rgba(244, 63, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0); }
        }

        /* Action Buttons */
        .btn-cut {
            background: linear-gradient(135deg, #f43f5e, #e11d48);
            color: white;
            box-shadow: 0 8px 20px rgba(244, 63, 94, 0.4);
            animation: pulse-glow 2s infinite;
        }
        .btn-cut:active { transform: scale(0.95) rotate(3deg); }

        .btn-reset {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        .btn-reset:active { transform: scale(0.95); }

        /* Menus */
        .menu-dropdown {
            transform-origin: top left;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
        }
        .scale-0-opacity-0 { transform: scale(0.8); opacity: 0; pointer-events: none; }
        .scale-100-opacity-100 { transform: scale(1); opacity: 1; pointer-events: auto; }

        .color-swatch {
            width: 24px; height: 24px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer; transition: transform 0.2s;
        }
        .color-swatch:hover { transform: scale(1.2); border-color: white; }
        
        .shape-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(255,255,255,0.05); border-radius: 12px;
            transition: background 0.2s;
        }
        .shape-btn:hover { background: rgba(255,255,255,0.15); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="fixed top-0 left-0 p-5 flex gap-3 pointer-events-none z-50 items-start">
        
        <div class="relative pointer-events-auto">
            <button id="btn-shape-toggle" class="glass-btn w-12 h-12 rounded-2xl flex items-center justify-center">
                <i id="current-shape-icon" class="fas fa-shapes"></i>
            </button>
            <div id="shape-menu" class="menu-dropdown absolute top-14 left-0 bg-slate-800/95 backdrop-blur-xl border border-slate-600 rounded-2xl p-3 w-56 shadow-2xl scale-0-opacity-0 grid grid-cols-3 gap-2">
                <button onclick="changeShape('cone')" class="shape-btn p-3 text-yellow-400"><i class="fas fa-filter transform rotate-180"></i><span class="text-[9px] text-gray-300">Cone</span></button>
                <button onclick="changeShape('cube')" class="shape-btn p-3 text-blue-400"><i class="fas fa-cube"></i><span class="text-[9px] text-gray-300">Cube</span></button>
                <button onclick="changeShape('sphere')" class="shape-btn p-3 text-red-400"><i class="fas fa-circle"></i><span class="text-[9px] text-gray-300">Sphere</span></button>
                <button onclick="changeShape('cylinder')" class="shape-btn p-3 text-green-400"><i class="fas fa-database"></i><span class="text-[9px] text-gray-300">Cylinder</span></button>
                <button onclick="changeShape('torus')" class="shape-btn p-3 text-purple-400"><i class="fas fa-ring"></i><span class="text-[9px] text-gray-300">Torus</span></button>
                <button onclick="changeShape('icosahedron')" class="shape-btn p-3 text-orange-400"><i class="fas fa-dice-d20"></i><span class="text-[9px] text-gray-300">Icosa</span></button>
            </div>
        </div>

        <div class="relative pointer-events-auto">
            <button id="btn-color-toggle" class="glass-btn w-12 h-12 rounded-2xl flex items-center justify-center">
                <i class="fas fa-palette"></i>
            </button>
            <div id="color-menu" class="menu-dropdown absolute top-14 left-0 bg-slate-800/95 backdrop-blur-xl border border-slate-600 rounded-2xl p-4 w-48 shadow-2xl scale-0-opacity-0">
                <p class="text-[10px] text-gray-400 uppercase tracking-wider mb-2 font-bold">Shape Color</p>
                <div class="flex flex-wrap gap-2 mb-4">
                    <div onclick="changeColor(0x06b6d4, 0xf43f5e)" class="color-swatch bg-cyan-500 shadow-[0_0_10px_#06b6d4]"></div>
                    <div onclick="changeColor(0xf59e0b, 0x3b82f6)" class="color-swatch bg-amber-500 shadow-[0_0_10px_#f59e0b]"></div>
                    <div onclick="changeColor(0x10b981, 0x8b5cf6)" class="color-swatch bg-emerald-500 shadow-[0_0_10px_#10b981]"></div>
                    <div onclick="changeColor(0xec4899, 0xfacc15)" class="color-swatch bg-pink-500 shadow-[0_0_10px_#ec4899]"></div>
                    <div onclick="changeColor(0x6366f1, 0x14b8a6)" class="color-swatch bg-indigo-500 shadow-[0_0_10px_#6366f1]"></div>
                </div>
            </div>
        </div>

        <button id="btn-ai" class="pointer-events-auto glass-btn w-12 h-12 rounded-2xl flex items-center justify-center hover:text-purple-400">
            <i class="fas fa-brain"></i>
        </button>
    </div>

    <div class="fixed top-0 right-0 p-5 z-50">
        <button id="btn-reset" class="pointer-events-auto btn-reset w-14 h-14 rounded-2xl flex flex-col items-center justify-center font-bold text-[10px] shadow-xl border border-white/20 active:scale-95 transition-transform">
            <i class="fas fa-redo text-lg mb-0.5"></i>
            RESET
        </button>
    </div>

    <div class="fixed bottom-10 left-0 right-0 z-50 flex justify-center items-center gap-6 pointer-events-none pb-4">
        
        <div class="pointer-events-auto bg-black/40 backdrop-blur-md rounded-full p-1.5 flex border border-white/10 shadow-xl">
            <button id="btn-mode-translate" class="active-mode w-12 h-12 rounded-full flex items-center justify-center transition-all">
                <i class="fas fa-arrows-alt"></i>
            </button>
            <button id="btn-mode-rotate" class="w-12 h-12 rounded-full text-slate-400 flex items-center justify-center transition-all hover:text-white hover:bg-white/10">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>

        <button id="btn-cut" class="pointer-events-auto btn-cut w-24 h-24 rounded-3xl rotate-3 flex flex-col items-center justify-center font-black text-sm shadow-2xl border border-white/20 active:scale-95 transition-transform hover:rotate-0 group">
            <i class="fas fa-cut text-3xl mb-1 group-hover:scale-110 transition-transform"></i>
            CUT
        </button>

    </div>

    <div id="ai-modal" class="hidden fixed inset-0 z-[70] flex items-end sm:items-center justify-center pointer-events-none bg-black/60 backdrop-blur-sm">
        <div class="bg-slate-900 text-white w-full sm:w-96 max-h-[80vh] sm:rounded-2xl rounded-t-2xl shadow-2xl border border-slate-700 flex flex-col pointer-events-auto transform transition-transform duration-300 translate-y-full">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50 rounded-t-2xl">
                <h3 class="font-bold text-cyan-400"><i class="fas fa-robot mr-2"></i>Gemini Analysis</h3>
                <button id="close-ai" class="text-gray-400 hover:text-white p-2"><i class="fas fa-times"></i></button>
            </div>
            <div id="ai-content" class="p-6 overflow-y-auto custom-scroll text-sm leading-relaxed text-slate-300"></div>
        </div>
    </div>

    <div id="loading-overlay" class="hidden fixed inset-0 bg-black/80 z-[80] flex flex-col items-center justify-center text-white backdrop-blur-sm">
        <div class="animate-spin rounded-full h-12 w-12 border-4 border-t-cyan-500 border-slate-700 mb-4"></div>
        <p class="text-sm font-bold animate-pulse text-cyan-400 tracking-widest">GEMINI IS THINKING...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        const apiKey = ""; 
        
        let scene, camera, renderer, orbitControls, transformControl;
        let objectGroup, bladeGroup, debrisGroup;
        let clipPlane, capMesh;
        
        // 상태 변수
        let isAnimating = false;
        let currentShapeType = 'cone';
        let currentShapeColor = 0x06b6d4;
        let currentCapColor = 0xf43f5e;
        
        // 초기 설정값 상수
        const INITIAL_CAMERA_POS = new THREE.Vector3(0, 12, 20);
        const INITIAL_BLADE_POS = new THREE.Vector3(0, 9, 0);
        const INITIAL_BLADE_QUAT = new THREE.Quaternion(); 

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); 
            scene.fog = new THREE.FogExp2(0x0f172a, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(INITIAL_CAMERA_POS);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            const rimLight = new THREE.SpotLight(0x22d3ee, 2.0); 
            rimLight.position.set(-10, 10, -10);
            scene.add(rimLight);

            // Clipping Plane
            clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);
            
            objectGroup = new THREE.Group();
            objectGroup.position.y = 3.5; 
            scene.add(objectGroup);
            
            // [추가] 파편 그룹 생성
            createDebrisPool();

            updateSolidShape('cone');

            createBlade();
            createFloor();

            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;

            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('change', () => renderer.render(scene, camera));
            transformControl.addEventListener('dragging-changed', (event) => {
                orbitControls.enabled = !event.value;
            });
            
            transformControl.setSpace('local');
            transformControl.attach(bladeGroup);
            scene.add(transformControl);
            
            transformControl.addEventListener('change', syncClippingPlaneToBlade);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            syncClippingPlaneToBlade();
        }

        // --- Core Functions ---
        
        function getGeometry(type) {
            switch(type) {
                case 'cone': return new THREE.CylinderGeometry(2.5, 4.5, 6, 64, 1, false);
                case 'cube': return new THREE.BoxGeometry(6, 6, 6);
                case 'sphere': return new THREE.SphereGeometry(3.5, 64, 64);
                case 'cylinder': return new THREE.CylinderGeometry(3.5, 3.5, 7, 64);
                case 'torus': return new THREE.TorusGeometry(3.5, 1.2, 48, 100);
                case 'icosahedron': return new THREE.IcosahedronGeometry(4, 0);
                default: return new THREE.BoxGeometry(5,5,5);
            }
        }

        function updateSolidShape(type) {
            // 기존 도형 제거
            while(objectGroup.children.length > 0){ 
                const child = objectGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                objectGroup.remove(child);
            }
            if(capMesh) { scene.remove(capMesh); capMesh.geometry.dispose(); capMesh.material.dispose(); }

            const geometry = getGeometry(type);

            const material = new THREE.MeshStandardMaterial({
                color: currentShapeColor, 
                emissive: new THREE.Color(currentShapeColor).multiplyScalar(0.2), 
                roughness: 0.2, metalness: 0.6,
                clippingPlanes: [clipPlane], clipShadows: true, side: THREE.FrontSide,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true; mesh.receiveShadow = true;
            objectGroup.add(mesh);

            const stencilGroup = createPlaneStencilGroup(geometry, clipPlane, 1);
            objectGroup.add(stencilGroup);

            const capMat = new THREE.MeshStandardMaterial({
                color: currentCapColor, emissive: new THREE.Color(currentCapColor).multiplyScalar(0.2),
                metalness: 0.1, roughness: 0.1,
                stencilWrite: true, stencilRef: 1, stencilFunc: THREE.EqualStencilFunc,
                stencilFail: THREE.KeepStencilOp, stencilZFail: THREE.KeepStencilOp, stencilZPass: THREE.KeepStencilOp,
                side: THREE.DoubleSide
            });
            capMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), capMat);
            capMesh.renderOrder = 1.1;
            
            if(bladeGroup) {
                capMesh.position.copy(bladeGroup.position);
                capMesh.quaternion.copy(bladeGroup.quaternion);
            }
            scene.add(capMesh);
            
            // [추가] 파편 색상 업데이트
            updateDebrisColor();
            
            syncClippingPlaneToBlade();
        }

        function createPlaneStencilGroup(geometry, plane, renderOrder) {
            const group = new THREE.Group();
            const baseMat = new THREE.MeshBasicMaterial({
                depthWrite: false, depthTest: false, colorWrite: false,
                stencilWrite: true, stencilFunc: THREE.AlwaysStencilFunc,
            });
            const mat0 = baseMat.clone(); mat0.side = THREE.BackSide; mat0.clippingPlanes = [plane];
            mat0.stencilFail = THREE.IncrementWrapStencilOp; mat0.stencilZFail = THREE.IncrementWrapStencilOp; mat0.stencilZPass = THREE.IncrementWrapStencilOp;
            group.add(new THREE.Mesh(geometry, mat0));

            const mat1 = baseMat.clone(); mat1.side = THREE.FrontSide; mat1.clippingPlanes = [plane];
            mat1.stencilFail = THREE.DecrementWrapStencilOp; mat1.stencilZFail = THREE.DecrementWrapStencilOp; mat1.stencilZPass = THREE.DecrementWrapStencilOp;
            group.add(new THREE.Mesh(geometry, mat1));
            return group;
        }

        function createBlade() {
            bladeGroup = new THREE.Group();
            bladeGroup.position.copy(INITIAL_BLADE_POS);

            const bladeGeo = new THREE.BoxGeometry(14, 0.05, 14);
            const bladeMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.9, roughness: 0.0, transmission: 0.3,
                transparent: true, opacity: 0.7, side: THREE.DoubleSide
            });
            const bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
            const edges = new THREE.EdgesGeometry(bladeGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x22d3ee }));
            bladeMesh.add(line);
            bladeGroup.add(bladeMesh);
            scene.add(bladeGroup);
        }

        function createFloor() {
            const grid = new THREE.GridHelper(50, 50, 0x334155, 0x1e293b);
            scene.add(grid);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.5 }));
            floor.rotation.x = -Math.PI / 2; floor.position.y = -0.01; floor.receiveShadow = true;
            scene.add(floor);
        }

        // [물리 효과 1] 파편 풀 생성
        function createDebrisPool() {
            debrisGroup = new THREE.Group();
            scene.add(debrisGroup);
            
            const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            // 초기 재질은 임시
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for(let i=0; i<25; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = false;
                debrisGroup.add(mesh);
            }
        }

        // [물리 효과 2] 파편 색상 동기화
        function updateDebrisColor() {
            if(!debrisGroup) return;
            debrisGroup.children.forEach(child => {
                child.material = new THREE.MeshStandardMaterial({
                    color: currentShapeColor,
                    emissive: new THREE.Color(currentCapColor),
                    roughness: 0.2,
                    metalness: 0.5
                });
            });
        }

        // [물리 효과 3] 폭발 이펙트 트리거
        function triggerPhysicsExplosion(position, bladeNormal) {
            // 1. 카메라 쉐이크
            gsap.to(camera.position, {
                x: "+=0.3", y: "+=0.3", 
                duration: 0.05, 
                yoyo: true, 
                repeat: 5,
                onComplete: () => {
                    // 원래 위치로 부드럽게 복귀 (살짝 틀어질 수 있으므로)
                    // orbitControls가 잡아주므로 크게 상관 없지만 안전장치
                }
            });

            // 2. 파편 튀기기
            debrisGroup.children.forEach((mesh, i) => {
                mesh.visible = true;
                mesh.scale.set(1,1,1);
                mesh.position.copy(position);
                
                // 랜덤 확산 위치 (칼날 평면 위주로)
                const randomOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 4
                );
                
                // 중력 효과 흉내
                const targetPos = position.clone().add(randomOffset);
                const dropY = -5 - Math.random() * 5;

                // 회전 랜덤
                const randomRot = {
                    x: Math.random() * Math.PI * 4,
                    y: Math.random() * Math.PI * 4
                };

                const tl = gsap.timeline();
                
                // 팍 튀었다가
                tl.to(mesh.position, {
                    x: targetPos.x,
                    y: targetPos.y + 2, // 살짝 위로 솟구침
                    z: targetPos.z,
                    duration: 0.3,
                    ease: "power2.out"
                })
                // 아래로 떨어지며 사라짐
                .to(mesh.position, {
                    y: dropY,
                    duration: 0.8,
                    ease: "bounce.out" // 바닥에 튕기는 느낌
                }, "-=0.1")
                .to(mesh.scale, {
                    x: 0, y: 0, z: 0,
                    duration: 0.5
                }, "-=0.8");

                // 회전 애니메이션
                gsap.to(mesh.rotation, {
                    x: randomRot.x,
                    y: randomRot.y,
                    duration: 1.0,
                    ease: "none"
                });
            });
        }


        function syncClippingPlaneToBlade() {
            if (!bladeGroup || !clipPlane || !capMesh) return;
            bladeGroup.updateMatrixWorld();
            
            const normal = new THREE.Vector3(0, -1, 0).applyQuaternion(bladeGroup.quaternion).normalize();
            const point = bladeGroup.position.clone();
            const constant = -point.dot(normal);
            
            clipPlane.normal.copy(normal);
            clipPlane.constant = constant; 
            
            capMesh.visible = true; 
            capMesh.position.copy(point);
            capMesh.quaternion.copy(bladeGroup.quaternion);
            capMesh.lookAt(point.clone().add(normal));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        // --- UI & Interactions ---

        const btnShapeToggle = document.getElementById('btn-shape-toggle');
        const shapeMenu = document.getElementById('shape-menu');
        const btnColorToggle = document.getElementById('btn-color-toggle');
        const colorMenu = document.getElementById('color-menu');
        
        const btnCut = document.getElementById('btn-cut');
        const btnReset = document.getElementById('btn-reset');
        
        const btnTranslate = document.getElementById('btn-mode-translate');
        const btnRotate = document.getElementById('btn-mode-rotate');

        function toggleMenu(menu, triggerBtn) {
            const isOpen = menu.classList.contains('scale-100-opacity-100');
            closeAllMenus(); 
            if (!isOpen) {
                menu.classList.remove('scale-0-opacity-0');
                menu.classList.add('scale-100-opacity-100');
            }
        }

        function closeAllMenus() {
            [shapeMenu, colorMenu].forEach(m => {
                m.classList.remove('scale-100-opacity-100');
                m.classList.add('scale-0-opacity-0');
            });
        }

        function toggleActiveMode(active, inactive) {
            active.classList.add('active-mode'); active.style.color = '#22d3ee';
            inactive.classList.remove('active-mode'); inactive.style.color = '#94a3b8';
        }

        btnShapeToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(shapeMenu); });
        btnColorToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(colorMenu); });
        document.addEventListener('click', closeAllMenus);

        window.changeShape = function(type) {
            if(isAnimating) return;
            currentShapeType = type;
            updateSolidShape(type);
            closeAllMenus();
        };

        window.changeColor = function(colorHex, capHex) {
            currentShapeColor = colorHex;
            currentCapColor = capHex;
            updateSolidShape(currentShapeType);
            closeAllMenus();
        };

        function onKeyDown(event) {
            if(!document.getElementById('ai-modal').classList.contains('hidden')) {
                if(event.key === 'Escape') document.getElementById('close-ai').click();
                return;
            }
            switch(event.key.toLowerCase()) {
                case 't': if(!isAnimating) document.getElementById('btn-mode-translate').click(); break;
                case 'r': if(!isAnimating) document.getElementById('btn-mode-rotate').click(); break;
                case ' ': case 'enter': btnCut.click(); break;
                case 'escape': btnReset.click(); closeAllMenus(); break;
            }
        }

        btnTranslate.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            transformControl.setMode('translate'); 
            transformControl.setSpace('local'); 
            toggleActiveMode(btnTranslate, btnRotate); 
        });
        
        btnRotate.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            transformControl.setMode('rotate'); 
            transformControl.setSpace('local'); 
            toggleActiveMode(btnRotate, btnTranslate); 
        });


        // ----------------------------------------------------
        // [CUT Logic] with Physics Effects
        // ----------------------------------------------------
        btnCut.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isAnimating) return; 
            isAnimating = true;
            transformControl.detach(); 

            // 1. 계산
            const bladeNormal = new THREE.Vector3(0, -1, 0)
                .applyQuaternion(bladeGroup.quaternion)
                .normalize();
            const worldDown = new THREE.Vector3(0, -1, 0); 
            
            const dot = worldDown.dot(bladeNormal);
            let cutDirection = worldDown.clone().sub(bladeNormal.clone().multiplyScalar(dot));

            if (cutDirection.lengthSq() < 0.0001) cutDirection.set(0, -1, 0); 
            else cutDirection.normalize();

            // 2. 타겟 위치
            const windUpDist = 3;  
            const cutDist = 20;    

            const startPos = bladeGroup.position.clone();
            const windUpPos = startPos.clone().add(cutDirection.clone().multiplyScalar(-windUpDist));
            const chopPos = startPos.clone().add(cutDirection.clone().multiplyScalar(cutDist));

            // [효과 위치] 칼이 도형의 대략적 중심(0, 3.5, 0)을 지나갈 때 이펙트 발생
            const impactPos = startPos.clone().add(cutDirection.clone().multiplyScalar(2));

            const tl = gsap.timeline({
                onComplete: () => {
                    isAnimating = false;
                    transformControl.attach(bladeGroup); 
                }
            });

            // Step A: Wind Up
            tl.to(bladeGroup.position, {
                x: windUpPos.x,
                y: windUpPos.y,
                z: windUpPos.z,
                duration: 0.2, 
                ease: "power2.out",
                onUpdate: syncClippingPlaneToBlade 
            });

            // Step B: Chop Down (물리 효과 트리거 포함)
            tl.to(bladeGroup.position, {
                x: chopPos.x,
                y: chopPos.y,
                z: chopPos.z,
                duration: 0.5, // 속도감 있게 더 빠르게
                ease: "power1.in", 
                onUpdate: syncClippingPlaneToBlade,
                onStart: () => {
                    // 칼이 내려가기 시작하고 아주 조금 뒤에 이펙트 터짐 (타이밍 조절)
                    setTimeout(() => {
                        triggerPhysicsExplosion(impactPos, bladeNormal);
                    }, 150);
                }
            });

            // Step C: Return (제자리로 복귀)
            tl.to(bladeGroup.position, {
                x: startPos.x,
                y: startPos.y,
                z: startPos.z,
                duration: 0.6,
                ease: "power2.out",
                onUpdate: syncClippingPlaneToBlade 
            });
        });

        // ----------------------------------------------------
        // [RESET Logic]
        // ----------------------------------------------------
        btnReset.addEventListener('click', (e) => {
            e.stopPropagation();
            
            gsap.killTweensOf(bladeGroup.position);
            gsap.killTweensOf(bladeGroup.rotation);
            gsap.killTweensOf(camera.position);
            
            // 파편 초기화
            if(debrisGroup) debrisGroup.children.forEach(c => c.visible = false);

            isAnimating = false;
            
            bladeGroup.position.copy(INITIAL_BLADE_POS);
            bladeGroup.quaternion.copy(INITIAL_BLADE_QUAT);
            
            currentShapeType = 'cone';
            currentShapeColor = 0x06b6d4;
            currentCapColor = 0xf43f5e;
            updateSolidShape('cone');

            gsap.to(camera.position, {
                x: INITIAL_CAMERA_POS.x,
                y: INITIAL_CAMERA_POS.y,
                z: INITIAL_CAMERA_POS.z,
                duration: 1.0,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0,0,0)
            });

            transformControl.attach(bladeGroup);
            transformControl.setMode('translate');
            toggleActiveMode(btnTranslate, btnRotate);
            
            syncClippingPlaneToBlade();
        });

        // AI Logic
        const btnAi = document.getElementById('btn-ai');
        const aiModal = document.getElementById('ai-modal');
        const closeAi = document.getElementById('close-ai');
        
        async function callGemini(prompt) {
            if (!apiKey) return "API Key Missing";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
            } catch (e) { return "Error"; }
        }

        btnAi.addEventListener('click', async (e) => {
            e.stopPropagation();
            aiModal.querySelector('div').classList.remove('translate-y-full');
            document.getElementById('loading-overlay').classList.remove('hidden');
            
            const prompt = `
                Math Teacher Persona. Korean Language.
                [Context] 3D Slicing App.
                [Shape] ${currentShapeType}
                [Blade] Pos: ${bladeGroup.position.toArray().map(v=>v.toFixed(1))}, Rot: ${bladeGroup.rotation.toArray().map(v=>(v*180/Math.PI).toFixed(0))}
                [Color] Main: ${new THREE.Color(currentShapeColor).getHexString()}, Inside: ${new THREE.Color(currentCapColor).getHexString()}
                
                Analyze the geometric cross-section formed by this cut. 
                Keep it fun and educational.
            `;

            const result = await callGemini(prompt);
            document.getElementById('ai-content').innerHTML = result.replace(/\*\*(.*?)\*\*/g, '<span class="text-cyan-400 font-bold">$1</span>').replace(/\n/g, '<br>');
            document.getElementById('loading-overlay').classList.add('hidden');
        });

        closeAi.addEventListener('click', () => {
            aiModal.querySelector('div').classList.add('translate-y-full');
        });

    </script>
</body>
</html>
