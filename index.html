<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Vivid Blade Slicer (Move Added)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0f172a; /* Slate-900 */
            font-family: 'Noto Sans KR', sans-serif; 
            overscroll-behavior: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            touch-action: none; 
        }

        /* ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ */
        input[type=range] {
            -webkit-appearance: none; 
            width: 100%;
            background: transparent; 
            cursor: pointer;
            touch-action: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.15);
            border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #22d3ee; /* Cyan-400 */
            margin-top: -6px; 
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
            border: 2px solid #fff;
        }

        /* ì•¡ì…˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .action-btn {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .action-btn:active {
            transform: scale(0.95);
        }
        
        /* í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(34, 211, 238, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0); }
        }
        .btn-pulse {
            animation: pulse-glow 2s infinite;
        }
    </style>
</head>
<body>

    <!-- 3D ìº”ë²„ìŠ¤ -->
    <div id="canvas-container"></div>

    <!-- ìƒë‹¨ íƒ€ì´í‹€ -->
    <div class="fixed top-6 left-0 right-0 text-center pointer-events-none z-40">
        <h1 class="text-2xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 drop-shadow-lg" style="text-shadow: 0 2px 10px rgba(0,0,0,0.5);">
            VIVID CUT
        </h1>
        <p class="text-xs text-cyan-200/70 mt-1">Move & Tilt & Cut</p>
    </div>

    <!-- AI ë¶„ì„ ë²„íŠ¼ (ì¢Œì¸¡ ìƒë‹¨) -->
    <button id="btn-ai" class="fixed top-6 left-6 z-50 bg-gray-800/80 backdrop-blur-md text-cyan-400 w-12 h-12 rounded-2xl shadow-lg border border-cyan-500/30 flex items-center justify-center hover:bg-gray-700 transition-all active:scale-90">
        <i class="fas fa-brain text-xl"></i>
    </button>

    <!-- ë©”ì¸ ì»¨íŠ¸ë¡¤ ë°” (í•˜ë‹¨) -->
    <div class="fixed bottom-6 left-4 right-4 z-50 flex flex-col gap-3 max-w-md mx-auto">
        
        <!-- ì¹¼ ì¡°ì ˆ ìŠ¬ë¼ì´ë” ê·¸ë£¹ -->
        <div class="bg-slate-900/80 backdrop-blur-xl rounded-2xl p-4 border border-slate-700 shadow-2xl space-y-3">
            
            <!-- 1. ì´ë™ (Shift/Move) - NEW -->
            <div>
                <div class="flex justify-between text-xs font-bold text-yellow-300 mb-1">
                    <span>â†”ï¸ BLADE SHIFT (ì´ë™)</span>
                    <span id="val-shift">0.0</span>
                </div>
                <input type="range" id="slider-shift" min="-4" max="4" step="0.1" value="0">
            </div>

            <!-- 2. ê¸°ìš¸ê¸° (Tilt) -->
            <div>
                <div class="flex justify-between text-xs font-bold text-cyan-300 mb-1">
                    <span>ğŸ”ª BLADE TILT (ê¸°ìš¸ê¸°)</span>
                    <span id="val-tilt">0Â°</span>
                </div>
                <input type="range" id="slider-tilt" min="0" max="90" step="1" value="0">
            </div>

            <!-- 3. íšŒì „ (Rotate) -->
            <div>
                <div class="flex justify-between text-xs font-bold text-pink-300 mb-1">
                    <span>ğŸ”„ BLADE DIR (ë°©í–¥)</span>
                    <span id="val-rotate">0Â°</span>
                </div>
                <input type="range" id="slider-rotate" min="0" max="360" step="1" value="0">
            </div>
        </div>

        <!-- ìë¥´ê¸° ì•¡ì…˜ ë²„íŠ¼ -->
        <button id="btn-action" class="action-btn btn-pulse w-full bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-black text-xl py-3.5 rounded-2xl shadow-[0_0_20px_rgba(6,182,212,0.5)] border-t border-white/20 flex items-center justify-center gap-3">
            <i class="fas fa-cut"></i> CUT !
        </button>
    </div>

    <!-- AI ê²°ê³¼ ëª¨ë‹¬ -->
    <div id="ai-modal" class="hidden fixed inset-0 z-[70] flex items-end sm:items-center justify-center pointer-events-none bg-black/50 backdrop-blur-sm">
        <div class="bg-slate-900 text-white w-full sm:w-96 max-h-[80vh] sm:rounded-2xl rounded-t-2xl shadow-2xl border border-slate-700 flex flex-col pointer-events-auto transform transition-transform duration-300 translate-y-full">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50 rounded-t-2xl">
                <h3 class="font-bold text-cyan-400"><i class="fas fa-robot mr-2"></i>AI Analysis</h3>
                <button id="close-ai" class="text-gray-400 hover:text-white p-2"><i class="fas fa-times"></i></button>
            </div>
            <div id="ai-content" class="p-6 overflow-y-auto custom-scroll text-sm leading-relaxed text-slate-300"></div>
        </div>
    </div>

    <!-- ë¡œë”© ì¸ë””ì¼€ì´í„° -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-black/80 z-[80] flex flex-col items-center justify-center text-white backdrop-blur-sm">
        <div class="animate-spin rounded-full h-14 w-14 border-4 border-t-cyan-500 border-slate-700 mb-4"></div>
        <p class="text-lg font-bold animate-pulse text-cyan-400">AI Calculating...</p>
    </div>

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- GSAP for Animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // ---------------------------------------------------------
        // 1. Global Setup
        // ---------------------------------------------------------
        const apiKey = ""; 
        
        let scene, camera, renderer, controls;
        let objectGroup, bladeGroup;
        let clipPlane, capMesh;
        
        let isCut = false;
        const bladeStartHeight = 7.0; 
        const bladeCutHeight = 0;     

        // ë„í˜• ë° ì¹¼ ì„¤ì •ê°’
        const params = {
            radiusTop: 2.5,
            radiusBottom: 4.5,
            height: 6.0,
            shift: 0,   // ì´ë™ (ì¢Œìš° offset)
            tilt: 0,    // ê¸°ìš¸ê¸°
            rotate: 0   // íšŒì „
        };

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); // Slate 900
            scene.fog = new THREE.FogExp2(0x0f172a, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);

            const rimLight = new THREE.SpotLight(0x22d3ee, 2.0); 
            rimLight.position.set(-10, 10, -10);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);

            // 1. Clipping Plane (Initial: normal pointing down)
            clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), bladeStartHeight);

            // 2. Object (Cone)
            objectGroup = new THREE.Group();
            scene.add(objectGroup);
            createSolidCone();

            // 3. Blade Visual
            createBlade();

            // 4. Floor
            createFloor();

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; 

            window.addEventListener('resize', onWindowResize);
        }

        // ---------------------------------------------------------
        // 2. Object Creation
        // ---------------------------------------------------------
        function createSolidCone() {
            const geometry = new THREE.CylinderGeometry(
                params.radiusTop, params.radiusBottom, params.height, 
                64, 1, false
            );

            // Vivid Exterior (Cyan)
            const material = new THREE.MeshStandardMaterial({
                color: 0x06b6d4, 
                emissive: 0x083344,
                roughness: 0.2,
                metalness: 0.6,
                clippingPlanes: [clipPlane],
                clipShadows: true,
                side: THREE.FrontSide,
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            objectGroup.add(mesh);

            // Stencil Logic for Cap
            const stencilGroup = createPlaneStencilGroup(geometry, clipPlane, 1);
            objectGroup.add(stencilGroup);

            // Cap Material (Hot Pink)
            const capMat = new THREE.MeshStandardMaterial({
                color: 0xf43f5e, 
                emissive: 0x881337,
                metalness: 0.1,
                roughness: 0.1,
                stencilWrite: true,
                stencilRef: 1,
                stencilFunc: THREE.EqualStencilFunc,
                stencilFail: THREE.KeepStencilOp,
                stencilZFail: THREE.KeepStencilOp,
                stencilZPass: THREE.KeepStencilOp,
                side: THREE.DoubleSide
            });

            const capGeo = new THREE.PlaneGeometry(40, 40);
            capMesh = new THREE.Mesh(capGeo, capMat);
            capMesh.renderOrder = 1.1;
            scene.add(capMesh); 
        }

        function createPlaneStencilGroup(geometry, plane, renderOrder) {
            const group = new THREE.Group();
            const baseMat = new THREE.MeshBasicMaterial({
                depthWrite: false, depthTest: false, colorWrite: false,
                stencilWrite: true, stencilFunc: THREE.AlwaysStencilFunc,
            });

            // Back faces
            const mat0 = baseMat.clone();
            mat0.side = THREE.BackSide;
            mat0.clippingPlanes = [plane];
            mat0.stencilFail = THREE.IncrementWrapStencilOp;
            mat0.stencilZFail = THREE.IncrementWrapStencilOp;
            mat0.stencilZPass = THREE.IncrementWrapStencilOp;
            const mesh0 = new THREE.Mesh(geometry, mat0);
            mesh0.renderOrder = renderOrder;
            group.add(mesh0);

            // Front faces
            const mat1 = baseMat.clone();
            mat1.side = THREE.FrontSide;
            mat1.clippingPlanes = [plane];
            mat1.stencilFail = THREE.DecrementWrapStencilOp;
            mat1.stencilZFail = THREE.DecrementWrapStencilOp;
            mat1.stencilZPass = THREE.DecrementWrapStencilOp;
            const mesh1 = new THREE.Mesh(geometry, mat1);
            mesh1.renderOrder = renderOrder;
            group.add(mesh1);

            return group;
        }

        function createBlade() {
            bladeGroup = new THREE.Group();
            bladeGroup.position.y = bladeStartHeight; 

            // Blade Geometry (Large thin box)
            const bladeGeo = new THREE.BoxGeometry(14, 0.1, 14);
            
            // Blade Material (Semi-transparent)
            const bladeMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.0,
                transmission: 0.3, 
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });

            const bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
            bladeMesh.castShadow = true;
            
            // Glowing Edge
            const edges = new THREE.EdgesGeometry(bladeGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x22d3ee }));
            bladeMesh.add(line);

            bladeGroup.add(bladeMesh);
            scene.add(bladeGroup);
        }

        function createFloor() {
            const grid = new THREE.GridHelper(50, 50, 0x334155, 0x1e293b);
            scene.add(grid);
            
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.ShadowMaterial({ opacity: 0.5 });
            const floor = new THREE.Mesh(planeGeo, planeMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.01;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        // ---------------------------------------------------------
        // 3. Sync Logic (Critical for Clipping)
        // ---------------------------------------------------------
        function syncClippingPlaneToBlade() {
            if (!bladeGroup || !clipPlane) return;

            bladeGroup.updateMatrixWorld();
            
            // Blade's down vector is (0, -1, 0) in local space
            const normal = new THREE.Vector3(0, -1, 0);
            normal.applyQuaternion(bladeGroup.quaternion).normalize();
            
            const point = bladeGroup.position.clone();
            const constant = -point.dot(normal);

            clipPlane.normal.copy(normal);
            clipPlane.constant = constant;

            // Update Cap Mesh
            capMesh.position.copy(point);
            capMesh.quaternion.copy(bladeGroup.quaternion);
            
            // Rotate Cap Mesh to face the normal (since PlaneGeometry faces Z+)
            // Or simply lookAt. Since we copied quaternion from a box whose down face is -Y,
            // and Plane is +Z.
            // Let's align manually to be safe.
            capMesh.lookAt(point.clone().add(normal));
        }

        function updateBladeTransform() {
            // Position Y handles by Animation or Reset
            if (!isCut) {
                bladeGroup.position.y = bladeStartHeight;
            }
            
            // 1. ì´ë™ ì ìš© (Xì¶• ê¸°ì¤€ ì¢Œìš° ì´ë™)
            bladeGroup.position.x = params.shift;
            
            // 2. íšŒì „ ì ìš©
            // Reset rotation
            bladeGroup.rotation.set(0, 0, 0);
            
            // Order matters: Rotate Direction (Y) -> Tilt (X)
            bladeGroup.rotateY(THREE.Math.degToRad(params.rotate));
            bladeGroup.rotateX(THREE.Math.degToRad(params.tilt));
            
            syncClippingPlaneToBlade();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            syncClippingPlaneToBlade(); // Always sync for animation smoothness
            renderer.render(scene, camera);
        }

        // ---------------------------------------------------------
        // 4. UI & Interaction
        // ---------------------------------------------------------
        const sliderShift = document.getElementById('slider-shift');
        const sliderTilt = document.getElementById('slider-tilt');
        const sliderRotate = document.getElementById('slider-rotate');
        
        const valShift = document.getElementById('val-shift');
        const valTilt = document.getElementById('val-tilt');
        const valRotate = document.getElementById('val-rotate');
        
        const btnAction = document.getElementById('btn-action');

        function onSliderChange() {
            if(isCut) return; 
            
            params.shift = parseFloat(sliderShift.value);
            params.tilt = parseFloat(sliderTilt.value);
            params.rotate = parseFloat(sliderRotate.value);
            
            valShift.innerText = params.shift.toFixed(1);
            valTilt.innerText = params.tilt + 'Â°';
            valRotate.innerText = params.rotate + 'Â°';
            
            updateBladeTransform();
        }

        sliderShift.addEventListener('input', onSliderChange);
        sliderTilt.addEventListener('input', onSliderChange);
        sliderRotate.addEventListener('input', onSliderChange);

        btnAction.addEventListener('click', () => {
            if (!isCut) {
                // [CUT Action]
                isCut = true;
                
                // UI Lock
                sliderShift.disabled = true;
                sliderTilt.disabled = true;
                sliderRotate.disabled = true;
                document.querySelector('.bg-slate-900\\/80').classList.add('opacity-50');
                
                // Animate Down
                gsap.to(bladeGroup.position, {
                    y: bladeCutHeight,
                    duration: 0.8,
                    ease: "power4.inOut",
                    onComplete: () => {
                        btnAction.innerHTML = '<i class="fas fa-undo"></i> RESET';
                        btnAction.classList.remove('from-cyan-500', 'to-blue-600', 'btn-pulse');
                        btnAction.classList.add('from-pink-500', 'to-rose-600');
                    }
                });

            } else {
                // [RESET Action]
                isCut = false;
                
                // UI Unlock
                sliderShift.disabled = false;
                sliderTilt.disabled = false;
                sliderRotate.disabled = false;
                document.querySelector('.bg-slate-900\\/80').classList.remove('opacity-50');

                // Animate Up
                gsap.to(bladeGroup.position, {
                    y: bladeStartHeight,
                    duration: 1.0,
                    ease: "power2.out",
                    onComplete: () => {
                        btnAction.innerHTML = '<i class="fas fa-cut"></i> CUT !';
                        btnAction.classList.remove('from-pink-500', 'to-rose-600');
                        btnAction.classList.add('from-cyan-500', 'to-blue-600', 'btn-pulse');
                    }
                });
            }
        });

        // --- AI Logic ---
        const btnAi = document.getElementById('btn-ai');
        const aiModal = document.getElementById('ai-modal');
        const closeAi = document.getElementById('close-ai');
        
        async function callGemini(prompt) {
            if (!apiKey) return "API í‚¤ ë¯¸ì„¤ì •";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "ë¶„ì„ ì‹¤íŒ¨";
            } catch (e) { return "ì˜¤ë¥˜ ë°œìƒ"; }
        }

        btnAi.addEventListener('click', async () => {
            aiModal.querySelector('div').classList.remove('translate-y-full');
            document.getElementById('loading-overlay').classList.remove('hidden');
            
            const stateDesc = isCut ? "ë„í˜•ì´ ì˜ë¦° ìƒíƒœ" : "ìë¥´ê¸° ì „ ì„¤ì • ë‹¨ê³„";

            const prompt = `
                ìˆ˜í•™ ì„ ìƒë‹˜ í˜ë¥´ì†Œë‚˜. í•œêµ­ì–´ë¡œ ë‹µë³€.
                [ìƒí™©] 3D ì›ë¿”ëŒ€ ì ˆë‹¨ ì‹œë®¬ë ˆì´ì…˜. ${stateDesc}.
                [íŒŒë¼ë¯¸í„°]
                - ìœ—ë©´ ë°˜ì§€ë¦„: ${params.radiusTop}
                - ì•„ë«ë©´ ë°˜ì§€ë¦„: ${params.radiusBottom}
                - ë†’ì´: ${params.height}
                - ì¹¼ ì´ë™(Shift): ${params.shift} (ì¤‘ì‹¬ì¶•ìœ¼ë¡œë¶€í„° ê±°ë¦¬)
                - ì¹¼ ê¸°ìš¸ê¸°(Tilt): ${params.tilt}ë„
                - ì¹¼ ë°©í–¥(Rotate): ${params.rotate}ë„
                
                [ìš”ì²­]
                1. í˜„ì¬ ì„¤ì •(ì´ë™ê°’ê³¼ ê°ë„)ìœ¼ë¡œ ì˜ëì„ ë•Œ ì˜ˆìƒë˜ëŠ” 'ë‹¨ë©´ì˜ ê¸°í•˜í•™ì  ëª¨ì–‘'(ì›, íƒ€ì›, í¬ë¬¼ì„ , ìŒê³¡ì„ , ì´ë“±ë³€ì‚¼ê°í˜• ë“±)ì„ ì¶”ë¡ í•˜ê³  ì„¤ëª…í•´ì¤˜.
                2. 'ì´ë™(Shift)' ê°’ì´ ë‹¨ë©´ ëª¨ì–‘ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ì„¤ëª…í•´ì¤˜ (ì˜ˆ: ì¤‘ì‹¬ì„ ì§€ë‚˜ë©´ ì‚¼ê°í˜•, ë²—ì–´ë‚˜ë©´ ìŒê³¡ì„  ë“±).
                3. ì¬ë¯¸ìˆëŠ” ê¸°í•˜í•™ í€´ì¦ˆ í•˜ë‚˜ ë‚´ì¤˜.
            `;

            const result = await callGemini(prompt);
            const formatted = result.replace(/\*\*(.*?)\*\*/g, '<span class="text-cyan-400 font-bold">$1</span>').replace(/\n/g, '<br>');
            document.getElementById('ai-content').innerHTML = formatted;
            document.getElementById('loading-overlay').classList.add('hidden');
        });

        closeAi.addEventListener('click', () => {
            aiModal.querySelector('div').classList.add('translate-y-full');
        });

        // Initial
        updateBladeTransform();

    </script>
</body>
</html>
