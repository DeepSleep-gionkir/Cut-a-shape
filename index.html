<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Multi-Slice 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0f172a; 
            font-family: 'Helvetica Neue', 'Noto Sans KR', sans-serif; 
            overscroll-behavior: none;
            user-select: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            touch-action: none; 
            outline: none;
        }

        /* Glass Button Style */
        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .glass-btn:active {
            transform: scale(0.92);
            background: rgba(255, 255, 255, 0.2);
        }
        
        .active-mode {
            background: rgba(34, 211, 238, 0.2);
            border-color: #22d3ee;
            color: #22d3ee;
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.2);
        }

        /* CUT Button Animation */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0.6); }
            70% { box-shadow: 0 0 0 15px rgba(244, 63, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0); }
        }

        /* Action Buttons */
        .btn-cut {
            background: linear-gradient(135deg, #f43f5e, #e11d48);
            color: white;
            box-shadow: 0 8px 20px rgba(244, 63, 94, 0.4);
            animation: pulse-glow 2s infinite;
        }
        .btn-cut:active { transform: scale(0.95) rotate(3deg); }

        .btn-reset {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        .btn-reset:active { transform: scale(0.95); }

        /* Menus */
        .menu-dropdown {
            transform-origin: top left;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
        }
        .scale-0-opacity-0 { transform: scale(0.8); opacity: 0; pointer-events: none; }
        .scale-100-opacity-100 { transform: scale(1); opacity: 1; pointer-events: auto; }

        .color-swatch {
            width: 24px; height: 24px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer; transition: transform 0.2s;
        }
        .color-swatch:hover { transform: scale(1.2); border-color: white; }
        
        .shape-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(255,255,255,0.05); border-radius: 12px;
            transition: background 0.2s;
        }
        .shape-btn:hover { background: rgba(255,255,255,0.15); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="fixed top-0 left-0 p-5 flex gap-3 pointer-events-none z-50 items-start">
        
        <div class="relative pointer-events-auto">
            <button id="btn-shape-toggle" class="glass-btn w-12 h-12 rounded-2xl flex items-center justify-center">
                <i id="current-shape-icon" class="fas fa-shapes"></i>
            </button>
            <div id="shape-menu" class="menu-dropdown absolute top-14 left-0 bg-slate-800/95 backdrop-blur-xl border border-slate-600 rounded-2xl p-3 w-56 shadow-2xl scale-0-opacity-0 grid grid-cols-3 gap-2">
                <button onclick="changeShape('cone')" class="shape-btn p-3 text-yellow-400"><i class="fas fa-filter transform rotate-180"></i><span class="text-[9px] text-gray-300">Cone</span></button>
                <button onclick="changeShape('cube')" class="shape-btn p-3 text-blue-400"><i class="fas fa-cube"></i><span class="text-[9px] text-gray-300">Cube</span></button>
                <button onclick="changeShape('sphere')" class="shape-btn p-3 text-red-400"><i class="fas fa-circle"></i><span class="text-[9px] text-gray-300">Sphere</span></button>
                <button onclick="changeShape('cylinder')" class="shape-btn p-3 text-green-400"><i class="fas fa-database"></i><span class="text-[9px] text-gray-300">Cylinder</span></button>
                <button onclick="changeShape('torus')" class="shape-btn p-3 text-purple-400"><i class="fas fa-ring"></i><span class="text-[9px] text-gray-300">Torus</span></button>
                <button onclick="changeShape('icosahedron')" class="shape-btn p-3 text-orange-400"><i class="fas fa-dice-d20"></i><span class="text-[9px] text-gray-300">Icosa</span></button>
            </div>
        </div>

        <div class="relative pointer-events-auto">
            <button id="btn-color-toggle" class="glass-btn w-12 h-12 rounded-2xl flex items-center justify-center">
                <i class="fas fa-palette"></i>
            </button>
            <div id="color-menu" class="menu-dropdown absolute top-14 left-0 bg-slate-800/95 backdrop-blur-xl border border-slate-600 rounded-2xl p-4 w-48 shadow-2xl scale-0-opacity-0">
                <p class="text-[10px] text-gray-400 uppercase tracking-wider mb-2 font-bold">Shape Color</p>
                <div class="flex flex-wrap gap-2 mb-4">
                    <div onclick="changeColor(0x06b6d4, 0xf43f5e)" class="color-swatch bg-cyan-500 shadow-[0_0_10px_#06b6d4]"></div>
                    <div onclick="changeColor(0xf59e0b, 0x3b82f6)" class="color-swatch bg-amber-500 shadow-[0_0_10px_#f59e0b]"></div>
                    <div onclick="changeColor(0x10b981, 0x8b5cf6)" class="color-swatch bg-emerald-500 shadow-[0_0_10px_#10b981]"></div>
                    <div onclick="changeColor(0xec4899, 0xfacc15)" class="color-swatch bg-pink-500 shadow-[0_0_10px_#ec4899]"></div>
                    <div onclick="changeColor(0x6366f1, 0x14b8a6)" class="color-swatch bg-indigo-500 shadow-[0_0_10px_#6366f1]"></div>
                </div>
            </div>
        </div>

        <button id="btn-ai" class="pointer-events-auto glass-btn w-12 h-12 rounded-2xl flex items-center justify-center hover:text-purple-400">
            <i class="fas fa-brain"></i>
        </button>
    </div>

    <div class="fixed top-0 right-0 p-5 z-50">
        <button id="btn-reset" class="pointer-events-auto btn-reset w-14 h-14 rounded-2xl flex flex-col items-center justify-center font-bold text-[10px] shadow-xl border border-white/20 active:scale-95 transition-transform">
            <i class="fas fa-redo text-lg mb-0.5"></i>
            RESET
        </button>
    </div>

    <div class="fixed bottom-10 left-0 right-0 z-50 flex justify-center items-center gap-6 pointer-events-none pb-4">
        
        <div class="pointer-events-auto bg-black/40 backdrop-blur-md rounded-full p-1.5 flex border border-white/10 shadow-xl">
            <button id="btn-mode-translate" class="active-mode w-12 h-12 rounded-full flex items-center justify-center transition-all">
                <i class="fas fa-arrows-alt"></i>
            </button>
            <button id="btn-mode-rotate" class="w-12 h-12 rounded-full text-slate-400 flex items-center justify-center transition-all hover:text-white hover:bg-white/10">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>

        <button id="btn-cut" class="pointer-events-auto btn-cut w-24 h-24 rounded-3xl rotate-3 flex flex-col items-center justify-center font-black text-sm shadow-2xl border border-white/20 active:scale-95 transition-transform hover:rotate-0 group">
            <i class="fas fa-cut text-3xl mb-1 group-hover:scale-110 transition-transform"></i>
            CUT
        </button>

    </div>

    <div id="ai-modal" class="hidden fixed inset-0 z-[70] flex items-end sm:items-center justify-center pointer-events-none bg-black/60 backdrop-blur-sm">
        <div class="bg-slate-900 text-white w-full sm:w-96 max-h-[80vh] sm:rounded-2xl rounded-t-2xl shadow-2xl border border-slate-700 flex flex-col pointer-events-auto transform transition-transform duration-300 translate-y-full">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50 rounded-t-2xl">
                <h3 class="font-bold text-cyan-400"><i class="fas fa-robot mr-2"></i>Gemini Analysis</h3>
                <button id="close-ai" class="text-gray-400 hover:text-white p-2"><i class="fas fa-times"></i></button>
            </div>
            <div id="ai-content" class="p-6 overflow-y-auto custom-scroll text-sm leading-relaxed text-slate-300"></div>
        </div>
    </div>

    <div id="loading-overlay" class="hidden fixed inset-0 bg-black/80 z-[80] flex flex-col items-center justify-center text-white backdrop-blur-sm">
        <div class="animate-spin rounded-full h-12 w-12 border-4 border-t-cyan-500 border-slate-700 mb-4"></div>
        <p class="text-sm font-bold animate-pulse text-cyan-400 tracking-widest">GEMINI IS THINKING...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        const apiKey = ""; 
        
        let scene, camera, renderer, orbitControls, transformControl;
        let objectGroup, bladeGroup, debrisGroup;
        let activePlanes = []; // 여러 개의 클리핑 평면을 저장할 배열
        let tempPlane, tempCapMesh; // 미리보기용 임시 평면과 캡
        let solidMesh, stencilGroup; // 메인 도형 참조
        
        // 상태 변수
        let isAnimating = false;
        let currentShapeType = 'cone';
        let currentShapeColor = 0x06b6d4;
        let currentCapColor = 0xf43f5e;
        
        // 초기 설정값 상수
        const INITIAL_CAMERA_POS = new THREE.Vector3(0, 12, 20);
        const INITIAL_BLADE_POS = new THREE.Vector3(0, 9, 0);
        const INITIAL_BLADE_QUAT = new THREE.Quaternion(); 

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); 
            scene.fog = new THREE.FogExp2(0x0f172a, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(INITIAL_CAMERA_POS);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            const rimLight = new THREE.SpotLight(0x22d3ee, 2.0); 
            rimLight.position.set(-10, 10, -10);
            scene.add(rimLight);

            // [핵심] 미리보기용 임시 평면 (초기에는 아무 효과 없도록 설정)
            tempPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);
            
            objectGroup = new THREE.Group();
            objectGroup.position.y = 3.5; 
            scene.add(objectGroup);
            
            createDebrisPool();
            updateSolidShape('cone');

            createBlade();
            createFloor();

            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;

            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('change', () => renderer.render(scene, camera));
            transformControl.addEventListener('dragging-changed', (event) => {
                orbitControls.enabled = !event.value;
            });
            
            transformControl.setSpace('local');
            transformControl.attach(bladeGroup);
            scene.add(transformControl);
            
            // 칼 움직일 때 미리보기 업데이트
            transformControl.addEventListener('change', syncPreviewPlaneToBlade);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            syncPreviewPlaneToBlade();
        }

        // --- Core Functions ---
        
        function getGeometry(type) {
            switch(type) {
                case 'cone': return new THREE.CylinderGeometry(2.5, 4.5, 6, 64, 1, false);
                case 'cube': return new THREE.BoxGeometry(6, 6, 6);
                case 'sphere': return new THREE.SphereGeometry(3.5, 64, 64);
                case 'cylinder': return new THREE.CylinderGeometry(3.5, 3.5, 7, 64);
                case 'torus': return new THREE.TorusGeometry(3.5, 1.2, 48, 100);
                case 'icosahedron': return new THREE.IcosahedronGeometry(4, 0);
                default: return new THREE.BoxGeometry(5,5,5);
            }
        }

        function updateSolidShape(type) {
            // 기존 도형 및 캡 정리
            while(objectGroup.children.length > 0){ 
                const child = objectGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                objectGroup.remove(child);
            }
            if(tempCapMesh) { scene.remove(tempCapMesh); tempCapMesh.geometry.dispose(); tempCapMesh.material.dispose(); }

            // 평면 배열 초기화 (새 도형 만들면 리셋)
            activePlanes = []; 

            const geometry = getGeometry(type);

            // 1. 메인 도형
            // [중요] clippingPlanes에 activePlanes와 tempPlane 모두 포함해야 함
            const material = new THREE.MeshStandardMaterial({
                color: currentShapeColor, 
                emissive: new THREE.Color(currentShapeColor).multiplyScalar(0.2), 
                roughness: 0.2, metalness: 0.6,
                clippingPlanes: [tempPlane], // 초기에는 tempPlane만
                clipShadows: true, side: THREE.DoubleSide, // 잘린 뒷면도 보여야 하므로 DoubleSide 권장
            });
            solidMesh = new THREE.Mesh(geometry, material);
            solidMesh.castShadow = true; mesh = solidMesh;
            objectGroup.add(solidMesh);

            // 2. 단면 채우기 (Stencil 방식 대신 단순화된 캡핑 방식 사용 - 다중 컷을 위해)
            // Stencil 방식은 다중 클리핑에서 매우 복잡해지므로, 
            // 여기서는 '미리보기용 캡'과 '영구적인 캡'을 따로 관리하거나, 
            // 가장 간단하게는 DoubleSide 재질로 안쪽 면을 보여주는 방식을 택함.
            // 하지만 "잘린 면의 색(Inside Color)"을 보여주기 위해 
            // 렌더링 순서 기법 등을 활용하는 것이 좋음.
            
            // 이 예제에서는 다중 컷의 복잡도를 줄이기 위해
            // 메인 도형을 DoubleSide로 하고, 잘린 면을 덮는 '미리보기 캡'만 보여줍니다.
            // 이미 잘린 면은 메인 도형의 안쪽 면(Inside) 색상으로 처리합니다.
            
            // * 메인 도형 안쪽 면 색상 적용을 위한 꼼수:
            // 도형을 하나 더 복사해서 안쪽 면(BackSide)만 렌더링하고 색상을 currentCapColor로 설정
            const insideMat = new THREE.MeshBasicMaterial({
                color: currentCapColor,
                side: THREE.BackSide,
                clippingPlanes: [tempPlane],
            });
            const insideMesh = new THREE.Mesh(geometry, insideMat);
            objectGroup.add(insideMesh);


            // 3. 현재 자르고 있는 단면(Preview Cap) 생성
            const capMat = new THREE.MeshStandardMaterial({
                color: currentCapColor, emissive: new THREE.Color(currentCapColor).multiplyScalar(0.2),
                metalness: 0.1, roughness: 0.1,
                side: THREE.DoubleSide,
                stencilWrite: false // Stencil 끄고 단순 평면으로
            });
            tempCapMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), capMat);
            tempCapMesh.renderOrder = 1;
            scene.add(tempCapMesh);
            
            updateDebrisColor();
            syncPreviewPlaneToBlade();
        }

        // 다중 자르기를 위해 재질의 Clipping Planes 배열 업데이트
        function updateMeshClippingPlanes() {
            // 활성 평면들 + 현재 미리보기 평면
            const allPlanes = [...activePlanes, tempPlane];
            
            objectGroup.children.forEach(mesh => {
                if (mesh.material) {
                    mesh.material.clippingPlanes = allPlanes;
                }
            });
        }

        function createBlade() {
            bladeGroup = new THREE.Group();
            bladeGroup.position.copy(INITIAL_BLADE_POS);

            const bladeGeo = new THREE.BoxGeometry(14, 0.05, 14);
            const bladeMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.9, roughness: 0.0, transmission: 0.3,
                transparent: true, opacity: 0.7, side: THREE.DoubleSide
            });
            const bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
            const edges = new THREE.EdgesGeometry(bladeGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x22d3ee }));
            bladeMesh.add(line);
            bladeGroup.add(bladeMesh);
            scene.add(bladeGroup);
        }

        function createFloor() {
            const grid = new THREE.GridHelper(50, 50, 0x334155, 0x1e293b);
            scene.add(grid);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.5 }));
            floor.rotation.x = -Math.PI / 2; floor.position.y = -0.01; floor.receiveShadow = true;
            scene.add(floor);
        }

        function createDebrisPool() {
            debrisGroup = new THREE.Group();
            scene.add(debrisGroup);
            const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for(let i=0; i<25; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = false;
                debrisGroup.add(mesh);
            }
        }

        function updateDebrisColor() {
            if(!debrisGroup) return;
            debrisGroup.children.forEach(child => {
                child.material = new THREE.MeshStandardMaterial({
                    color: currentShapeColor,
                    emissive: new THREE.Color(currentCapColor),
                    roughness: 0.2, metalness: 0.5
                });
            });
        }

        function triggerPhysicsExplosion(position, bladeNormal) {
            gsap.to(camera.position, {
                x: "+=0.3", y: "+=0.3", duration: 0.05, yoyo: true, repeat: 5
            });
            debrisGroup.children.forEach((mesh, i) => {
                mesh.visible = true;
                mesh.scale.set(1,1,1);
                mesh.position.copy(position);
                const randomOffset = new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*2, (Math.random()-0.5)*4);
                const targetPos = position.clone().add(randomOffset);
                const dropY = -5 - Math.random() * 5;
                const randomRot = { x: Math.random() * Math.PI * 4, y: Math.random() * Math.PI * 4 };

                const tl = gsap.timeline();
                tl.to(mesh.position, { x: targetPos.x, y: targetPos.y + 2, z: targetPos.z, duration: 0.3, ease: "power2.out" })
                  .to(mesh.position, { y: dropY, duration: 0.8, ease: "bounce.out" }, "-=0.1")
                  .to(mesh.scale, { x: 0, y: 0, z: 0, duration: 0.5 }, "-=0.8");
                gsap.to(mesh.rotation, { x: randomRot.x, y: randomRot.y, duration: 1.0, ease: "none" });
            });
        }

        // [핵심] 미리보기용 Plane 동기화
        function syncPreviewPlaneToBlade() {
            if (!bladeGroup || !tempPlane || !tempCapMesh) return;
            bladeGroup.updateMatrixWorld();
            
            const normal = new THREE.Vector3(0, -1, 0).applyQuaternion(bladeGroup.quaternion).normalize();
            const point = bladeGroup.position.clone();
            const constant = -point.dot(normal);
            
            // 임시 평면 업데이트 (화면 렌더링에 즉시 반영)
            tempPlane.normal.copy(normal);
            tempPlane.constant = constant;
            
            // 캡 메시 위치 업데이트
            tempCapMesh.visible = true; 
            tempCapMesh.position.copy(point);
            tempCapMesh.quaternion.copy(bladeGroup.quaternion);
            
            // 다중 평면 상태 업데이트
            updateMeshClippingPlanes();
        }

        // [핵심] 자르기 확정 (평면 저장)
        function commitCut() {
            // 현재 tempPlane 상태를 복제하여 영구 평면으로 저장
            const permanentPlane = new THREE.Plane(tempPlane.normal.clone(), tempPlane.constant);
            activePlanes.push(permanentPlane);
            
            // 캡 메시도 영구적으로 남기기 위해 복제
            const permCapGeo = new THREE.PlaneGeometry(50, 50);
            const permCapMat = new THREE.MeshStandardMaterial({
                color: currentCapColor, emissive: new THREE.Color(currentCapColor).multiplyScalar(0.2),
                metalness: 0.1, roughness: 0.1,
                side: THREE.DoubleSide,
                // 저장된 캡도 기존의 모든 잘린 평면들에 의해 잘려야 함 (서로 겹치지 않게)
                clippingPlanes: activePlanes 
            });
            const permCap = new THREE.Mesh(permCapGeo, permCapMat);
            permCap.position.copy(tempCapMesh.position);
            permCap.quaternion.copy(tempCapMesh.quaternion);
            scene.add(permCap);
            
            // 중요: 새로 생긴 캡도 이후의 컷에 의해 잘려야 함.
            // 하지만 Three.js Material의 clippingPlanes는 참조형이므로
            // 나중에 activePlanes 배열이 바뀌면 자동으로 반영됨.
            // 다만, '자기 자신'을 자르는 평면이 포함되면 렌더링이 사라질 수 있으므로 주의.
            // 여기서는 단순화를 위해 모든 캡이 모든 활성 평면을 공유하도록 함.
            
            // 기존 캡들 업데이트 (새로운 평면 적용)
            scene.traverse((obj) => {
                if (obj.isMesh && obj !== solidMesh && obj !== tempCapMesh && obj.parent !== objectGroup && obj.parent !== bladeGroup) {
                     // scene에 직접 추가된 영구 캡들
                     obj.material.clippingPlanes = [...activePlanes, tempPlane];
                }
            });

            // 임시 평면 초기화 (안 보이게 멀리 보냄 or 비활성화)
            // 다음 컷을 위해 tempPlane을 초기화하되, 
            // 현재 애니메이션이 '복귀' 중이므로 시각적으로 튀지 않게 처리해야 함.
            // 여기서는 단순히 tempPlane을 아주 멀리 보내거나 무효화시킴.
            // 그러나 사용자가 다시 칼을 잡으면 syncPreviewPlaneToBlade가 호출되어 다시 활성화됨.
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        // --- UI & Interactions ---
        const btnShapeToggle = document.getElementById('btn-shape-toggle');
        const shapeMenu = document.getElementById('shape-menu');
        const btnColorToggle = document.getElementById('btn-color-toggle');
        const colorMenu = document.getElementById('color-menu');
        const btnCut = document.getElementById('btn-cut');
        const btnReset = document.getElementById('btn-reset');
        const btnTranslate = document.getElementById('btn-mode-translate');
        const btnRotate = document.getElementById('btn-mode-rotate');

        function toggleMenu(menu, triggerBtn) {
            const isOpen = menu.classList.contains('scale-100-opacity-100');
            closeAllMenus(); 
            if (!isOpen) {
                menu.classList.remove('scale-0-opacity-0');
                menu.classList.add('scale-100-opacity-100');
            }
        }

        function closeAllMenus() {
            [shapeMenu, colorMenu].forEach(m => {
                m.classList.remove('scale-100-opacity-100');
                m.classList.add('scale-0-opacity-0');
            });
        }

        function toggleActiveMode(active, inactive) {
            active.classList.add('active-mode'); active.style.color = '#22d3ee';
            inactive.classList.remove('active-mode'); inactive.style.color = '#94a3b8';
        }

        btnShapeToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(shapeMenu); });
        btnColorToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(colorMenu); });
        document.addEventListener('click', closeAllMenus);

        window.changeShape = function(type) {
            if(isAnimating) return;
            currentShapeType = type;
            // 캡들 제거
            scene.children.slice().forEach(child => {
                 if(child.isMesh && child !== tempCapMesh && !objectGroup.children.includes(child) && !bladeGroup.children[0].children.includes(child) && child.geometry.type === 'PlaneGeometry' && child.material.color.getHex() === currentCapColor) {
                    scene.remove(child);
                 }
            });
            // scene에 직접 추가된 영구 캡들을 찾아서 지우는 로직이 좀 복잡할 수 있으니
            // 간단히 scene 전체 순회하며 제거 (Grid, Lights 제외)
            const toRemove = [];
            scene.traverse(o => {
                if(o.isMesh && o.geometry.type === 'PlaneGeometry' && o !== tempCapMesh && o.parent === scene) {
                    // floor 제외 확인 (floor는 ShadowMaterial)
                    if(o.material.type === 'MeshStandardMaterial') toRemove.push(o);
                }
            });
            toRemove.forEach(o => { scene.remove(o); if(o.geometry) o.geometry.dispose(); });

            updateSolidShape(type);
            closeAllMenus();
        };

        window.changeColor = function(colorHex, capHex) {
            currentShapeColor = colorHex;
            currentCapColor = capHex;
            updateSolidShape(currentShapeType);
            closeAllMenus();
        };

        function onKeyDown(event) {
            if(!document.getElementById('ai-modal').classList.contains('hidden')) {
                if(event.key === 'Escape') document.getElementById('close-ai').click();
                return;
            }
            switch(event.key.toLowerCase()) {
                case 't': if(!isAnimating) document.getElementById('btn-mode-translate').click(); break;
                case 'r': if(!isAnimating) document.getElementById('btn-mode-rotate').click(); break;
                case ' ': case 'enter': btnCut.click(); break;
                case 'escape': btnReset.click(); closeAllMenus(); break;
            }
        }

        btnTranslate.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            transformControl.setMode('translate'); 
            transformControl.setSpace('local'); 
            toggleActiveMode(btnTranslate, btnRotate); 
        });
        
        btnRotate.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            transformControl.setMode('rotate'); 
            transformControl.setSpace('local'); 
            toggleActiveMode(btnRotate, btnTranslate); 
        });

        // ----------------------------------------------------
        // [CUT Logic] Multi-Slice
        // ----------------------------------------------------
        btnCut.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isAnimating) return; 
            isAnimating = true;
            transformControl.detach(); 

            // 벡터 계산
            const bladeNormal = new THREE.Vector3(0, -1, 0).applyQuaternion(bladeGroup.quaternion).normalize();
            const worldDown = new THREE.Vector3(0, -1, 0); 
            const dot = worldDown.dot(bladeNormal);
            let cutDirection = worldDown.clone().sub(bladeNormal.clone().multiplyScalar(dot));
            if (cutDirection.lengthSq() < 0.0001) cutDirection.set(0, -1, 0); 
            else cutDirection.normalize();

            const startPos = bladeGroup.position.clone();
            const windUpPos = startPos.clone().add(cutDirection.clone().multiplyScalar(-3));
            const chopPos = startPos.clone().add(cutDirection.clone().multiplyScalar(20));
            const impactPos = startPos.clone().add(cutDirection.clone().multiplyScalar(2));

            const tl = gsap.timeline({
                onComplete: () => {
                    isAnimating = false;
                    transformControl.attach(bladeGroup); 
                }
            });

            // Step A: Wind Up
            tl.to(bladeGroup.position, {
                x: windUpPos.x, y: windUpPos.y, z: windUpPos.z,
                duration: 0.2, ease: "power2.out",
                onUpdate: syncPreviewPlaneToBlade 
            });

            // Step B: Chop Down
            tl.to(bladeGroup.position, {
                x: chopPos.x, y: chopPos.y, z: chopPos.z,
                duration: 0.5, ease: "power1.in", 
                onUpdate: syncPreviewPlaneToBlade,
                onStart: () => {
                    setTimeout(() => triggerPhysicsExplosion(impactPos, bladeNormal), 150);
                },
                // [중요] 내려치기가 끝나는 순간(도형을 통과한 순간), 현재 컷을 확정함
                onComplete: () => {
                    commitCut(); 
                    // 컷 확정 후에는 tempPlane이 의미가 없어지거나 초기화되어야 함
                    // 하지만 복귀 동작에서 칼이 다시 올라오면서 또 잘리는 것처럼 보이면 이상함.
                    // 따라서 복귀 중에는 tempPlane을 비활성화(멀리 보냄)
                    tempPlane.constant = 10000; 
                    tempCapMesh.visible = false;
                }
            });

            // Step C: Return
            tl.to(bladeGroup.position, {
                x: startPos.x, y: startPos.y, z: startPos.z,
                duration: 0.6, ease: "power2.out",
                // 복귀 중에는 미리보기 업데이트 하지 않음 (이미 잘렸으니까)
            });
        });

        // ----------------------------------------------------
        // [RESET Logic]
        // ----------------------------------------------------
        btnReset.addEventListener('click', (e) => {
            e.stopPropagation();
            
            gsap.killTweensOf(bladeGroup.position);
            gsap.killTweensOf(bladeGroup.rotation);
            gsap.killTweensOf(camera.position);
            if(debrisGroup) debrisGroup.children.forEach(c => c.visible = false);

            isAnimating = false;
            
            bladeGroup.position.copy(INITIAL_BLADE_POS);
            bladeGroup.quaternion.copy(INITIAL_BLADE_QUAT);
            
            // 모든 영구 캡 제거
            const toRemove = [];
            scene.traverse(o => {
                if(o.isMesh && o.geometry.type === 'PlaneGeometry' && o !== tempCapMesh && o.parent === scene) {
                    if(o.material && o.material.type === 'MeshStandardMaterial') toRemove.push(o);
                }
            });
            toRemove.forEach(o => scene.remove(o));

            updateSolidShape(currentShapeType); // 초기화

            gsap.to(camera.position, {
                x: INITIAL_CAMERA_POS.x, y: INITIAL_CAMERA_POS.y, z: INITIAL_CAMERA_POS.z,
                duration: 1.0, ease: "power2.inOut", onUpdate: () => camera.lookAt(0,0,0)
            });

            transformControl.attach(bladeGroup);
            transformControl.setMode('translate');
            toggleActiveMode(btnTranslate, btnRotate);
            
            syncPreviewPlaneToBlade();
        });

        // AI Logic
        const btnAi = document.getElementById('btn-ai');
        const aiModal = document.getElementById('ai-modal');
        const closeAi = document.getElementById('close-ai');
        
        async function callGemini(prompt) {
            if (!apiKey) return "API Key Missing";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
            } catch (e) { return "Error"; }
        }

        btnAi.addEventListener('click', async (e) => {
            e.stopPropagation();
            aiModal.querySelector('div').classList.remove('translate-y-full');
            document.getElementById('loading-overlay').classList.remove('hidden');
            
            const prompt = `
                Math Teacher Persona. Korean Language.
                [Context] 3D Slicing App. Multi-slice mode active.
                [Cuts Made] ${activePlanes.length} cuts.
                [Shape] ${currentShapeType}
                [Blade] Pos: ${bladeGroup.position.toArray().map(v=>v.toFixed(1))}, Rot: ${bladeGroup.rotation.toArray().map(v=>(v*180/Math.PI).toFixed(0))}
                
                Explain what happens geometrically when we slice an object multiple times.
            `;

            const result = await callGemini(prompt);
            document.getElementById('ai-content').innerHTML = result.replace(/\*\*(.*?)\*\*/g, '<span class="text-cyan-400 font-bold">$1</span>').replace(/\n/g, '<br>');
            document.getElementById('loading-overlay').classList.add('hidden');
        });

        closeAi.addEventListener('click', () => {
            aiModal.querySelector('div').classList.add('translate-y-full');
        });

    </script>
</body>
</html>
